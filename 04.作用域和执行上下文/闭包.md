## 一、闭包是什么
在讲清楚闭包这个所有前端开发都需要掌握和了解的知识点之前，我们需要先了解两个和闭包形成密切相关的知识点：
1. 变量的作用域
2. 变量的生命周期

### 变量的作用域
在上一节作用域链及其查找机制中我们就说过，变量的作用域其实就是变量的有效范围。
对于全局作用域来说，变量的作用范围就是全局；对于函数作用域来说，变量的作用范围就是函数，但由于作用域链的查找机制，函数作用域中的变量可以访问全局变量的值，反过来全局作用域中的变量不能访问局部作用域的值。

### 变量的生命周期
一般情况下，JS的执行引擎比如V8都会周期性的执行垃圾回收机制，将哪些未使用或者使用过后不会再使用的变量所占有的空间进行回收，这种回收机制是自动的。

对于全局变量来说，除非我们手动的去销毁全局变量，否则这个全局变量的声明周期是永久性的，全局变量只有我们关闭了页面才会被销毁。

对于函数作用域的私有变量来说，包含形参以及在函数内部声明的变量都是私有变量，一般来说函数在执行完成之后，ESP指针下移，函数执行栈从栈顶弹出，该函数作用域销毁，所有私有变量都会被垃圾回收机制所回收。

由于JS中函数是一等公民的特点，函数不仅可以被当做参数传入，更是可以被当做返回值进行返回。如果某个函数的返回值是一个函数，返回到外部的这个函数可以访问到原函数被调用时产生的环境也就是函数作用域，而如果该函数作用域中存在着某个私有变量，那么这个私有变量就会被销毁。这里就产生了一个闭包结构。

```javascript

function A(){
	var y = 100;
	return function B(){
		console.log('888');
	}
}
var x = A();

```
A函数的执行结果是return B函数，恰好外部变量x接收了A函数执行的结果，那么此时A函数执行时形成的私有栈内存不可销毁。因为函数return的一定是一个确定的值，当值为引用类型的时候return的其实是引用值的16进制内存地址，所以全局变量x接收到的也是这个内存地址，此时x变量始终保持着对于该引用地址所指向堆内存的引用，所以函数A执行时形成的私有栈内存无法销毁。

综上所述,现在我们可以这样回答闭包是什么的问题：
```bash
函数在执行时会产生一个函数私有的作用域，当函数在执行时如果返回了另外一个函数引用，由于返回到外部的这个函数引用始终可以保持对于原函数私有作用域的访问，基于作用域链访问机制和函数作用域的变量回收机制，原函数私有作用域中的私有变量会由于闭包的存在而无法被销毁，我们把这种现象称之为闭包。

其实我们也可以简单的将闭包理解为是一个函数，只不过这个函数比较特殊，它是一个有权访问其他函数私有作用域中私有变量的函数，而一般情况下不同函数之间其作用域是互相隔离而无法访问的。
```


## 二、闭包的作用

### 闭包作用之保护全局变量污染
我们可以把一些不想暴露在全局的变量利用立即执行函数可以形成闭包的特点，将全局变量封装成为私有变量，起到一种保护全局变量的效果。

```js
var add = function(...args){
	return args.reduce((prev,curr)=>prev + curr);
}
```
首先add是一个全局变量，它用来计算传入参数的和。对于这个add函数本身来说，其实性能方面是有问题的，比如我们连续调用多次add方法传入相同的参数1,2,3其返回值是相同的，但是add函数内部需要执行3次运算。

我们希望对于相同的参数，我们不进行重复的计算，而是利用缓存机制直接返回函数的返回值。如下：
```js
var cache = new Map();
var add = function(...args){
	let params = args.sort((a,b)=>a-b).join();
	if(cache.has(params)){
		return cache.get(params);
	}
	
	let res = args.reduce((prev,curr)=>prev + curr);
	cache.set(params,res);
	return res;
}
```

但是现在新的问题又来了，为了实现缓存的效果我们声明了全局变量cache，很容易造成全局变量污染，所以我们要使用闭包将这个全局变量保护起来。如下所示，这是闭包最常见的引用也就是保护全局变量为私有变量避免其收到污染。
```js
var add = (function(){
	var cache = new Map();
	return function(...args){
		let params = args.sort((a,b)=>a-b).join();
		if(cache.has(params)){
			return cache.get(params);
		}
		// console.log(1)
		let res = args.reduce((prev,curr)=>prev + curr);
		cache.set(params,res);
		return res;
	}
})();
```

这个思路也经常被用来最初的模块化，那就是避免变量的命名空间受到全局变量的污染。
```js
var utils = (function(){
	function add(){}
	function mul(){}
	
	return {
		add,
		mul
	}
})();

utils.add();
utils.mul();
```


### 闭包作用之延长局部变量生命周期
比如我们经常使用img元素的src属性来做错误上报：
```js
function report(url){
	let img = new Image();
	img.src= url;
}
report('https://www.report.com/api/index');
```
以上这种方案会有一个问题，一些低版本浏览器的实现存在 bug，在这些浏览器下使用 report 函数进行数据上报会丢失 30%左右的数据，也就是说，report 函数并不是每一次都成功发起了 HTTP 请求。

丢失数据的原因是 img 是 report 函数中的局部变量，当 report 函数的调用结束后，img 局部变量随即被销毁，而此时或许还没来得及发出 HTTP 请求，所以此次请求就会丢失掉。

为了保证img元素一定在请求发出之前销毁，我们利用闭包将img变量封闭起来，避免其提前销毁。

```js
var report = (function (){
	let imgList = [];
	return function(url){
		let img = new Image();
		imgList.push(img);
		img.src= url;
	}
})();
```
由于report函数中的局部变量img始终被上一级作用域中的私有变量imgList所引用，所以不会提前销毁。




## 三、闭包之内存泄漏
一直以来都有一种说法是闭包的弊端会造成JS中变量无法销毁，从而导致内存泄漏，所以要尽量减少闭包的使用。

从局部变量销毁的时机来看，闭包确实会导致函数作用域中的变量无法被销毁，从而变量占有的内存空间无法被回收，导致内存泄漏。

但是还有一种情况是我们之所以在代码中使用闭包，很大程度上就是想要保护某个私有变量不被垃圾回收机制所回收，因为以后很有可能会使用到这个变量，此时把这个变量放到全局和私有作用域对内存的影响是一样的，如果以后不想要了，我们可以手动将其设置为null，然后就可以被垃圾回收机制所回收。

此外还有一种特殊的情况是闭包的作用域中如果保存了DOM节点的引用，并且此DOM节点和JS对象形成了循环引用，这时候就有可能造成内存泄露。但这本身并非闭包的问题，也并非 JavaScript 的问题。在 IE 浏览器中，由于 BOM 和 DOM 中的对象是使用 C++以 COM 对象的方式实现的，而 COM 对象的垃圾收集机制采用的是引用计数策略。在基于引用计数策略的垃圾回收机制中，如果两个对象之间形成了循环引用，那么这两个对象都无法被回收，但循环引用造成的内存泄露在本质上也不是闭包造成的。


## 四、闭包的练习题
重点理解：
+ 每执行一次就会形成一个全新的函数私有作用域
+ 局部变量和全局变量
 
### 1. 求下面代码输出结果
```js
var i = 5;
function fn(i){
	return function(n){
		console.log(n + (++i));
	}
}
var f = fn(1); 
f(2); // 4 i=2
fn(3)(4); // 8 i=4
fn(5)(6); // 12 i=7
f(7); // 10 i=3
console.log(i); // 5
```


### 2. 求下面代码输出结果
考察函数每执行一次就生成一个作用域以及闭包
```js
var i = 20;
function fn(){
	i-=2;
	return function(n){
		console.log((++i) - n);
	}
}
var f = fn(); // 形成新的fn作用域1, i = 18
f(1); // i = 19,输出19-1 = 18
f(2); // i = 20,输出20-2 = 18
fn()(3); // 形成新的fn作用域2，i = 20-2 = 18，输出18+1-3 = 16
fn()(4); // 形成新的fn作用域3，i = 19-2 = 17，输出17+1-4 = 14
f(5); // i = 18,输出18+1 - 5 = 14
console.log(i); // 输出19
```

### 3. 求下面代码输出结果
+ 作用域一定是栈内存,也叫执行上下文,查找上一级作用域,前提必须是一个栈内存,而对象{}存储在堆内存,所以一个作用域永远不可能是堆内存
+ alert出现那么输出值一定为字符串类型

```js
(function(){
	var a = 100;
	var obj = {
		a:200,
		demo:function(){
			a *= 2;
		}
	};
	obj.demo(); // 全局a = 200
	alert(obj.a + a); // 200 + 200 = 400 弹出字符串类型的'400'
})()
```

### 4. 求下面代码输出结果
主要需要注意的点和易错的点：
函数在执行是遇到变量遵循作用域链查找机制，但是要记住，只要是函数作用域那么一定是在栈内存中执行的，所以函数执行时的作用域一定是栈内存。不要将对象存储的堆内存中的键值对混淆了，尤其是私有的变量和对象中的私有属性一致的时候，更加容易混淆。

函数执行=== > 形成私有栈内存 ，执行时遇到变量遵循作用域链查找机制
对象存储=== > 将一个对象存储在堆内存中，不使用作用域链机制

```js
function fun(n,o){
	console.log(o);
	return {
		fun:function(m){
			return fun(m,n);
		}
	}
}
var c = fun(0).fun(1) // 分别打印undefined和0
c.fun(2); // return fun(2,1)  打印o变量,此时o为1
c.fun(3); // retrun fun(3,1)  打印o变量 此时o为1
```

### 5. 求下面代码输出结果
注意闭包的形成不一定是return一个函数到外部，只要外部的某个函数有权访问其他函数的私有变量，那么也可以说形成了闭包。
```js
var fun3;
function fun1() {
  var a = 2
  fun3 = function() {
    console.log(a);
  }
}
fun1(); // 函数执行后全局变量fun3引用了函数fun1私有作用域中定义的匿名函数，所以形成了闭包
fun3(); // 执行fun3函数，就可以在全局中访问到fun1作用域的私有变量a = 2

```


## 将一个函数私有作用域中的变量或方法暴露给全局的方法
1. 通过return私有方法到外部，然后外部通过全局变量接收
```javascript
function demo(){
	var name = 100;
	function add(a,b){
		return a+b;
	}
	return add;
}

var result = demo();
result(10,20); 结果是10+20 = 30
```

2. 通过给全局window对象增加属性，把私有的方法暴露到全局作用域中供全局调用
```js
function demo(){
	var name = 100;
	function add(a,b){
		return a+b;
	}
	window.add = add;
	或者
	window.$ = add;
}
demo();执行一次demo()函数将demo函数中私有的方法add暴露到了全局，然后全局就可以调用了
add(10,20);返回30
$(20,40);  返回60

```