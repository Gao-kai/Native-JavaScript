### JS作用域链查找机制
1. 什么是作用域链？
函数在执行时会形成一个私有的函数作用域，在函数作用域中访问一个变量，首选会在当前私有作用域中查找该变量是否被定义，如果有就用当前作用域的，如果没有就向上一级的作用域中查找该变量是否被定义，一直查找到作用域的最顶端window全局作用域，如果还是没有找到那么可能会报错：xxx is not defined。这种一级一级向上查找的机制叫做作用域链查找机制。

函数执行时会形成一个私有作用域，将其私有作用域中的所有私有变量保护起来，所以外部作用域不可以访问函数的私有作用域中变量，这种函数*保护*其私有作用域中变量的机制叫做'闭包'。

2. 如何查找上级作用域
作用域链的查找机制的关键在于如何查找上级作用域
1.从函数创建的那一刻开始，该函数的作用域就已经确定。
2.当前函数A是在作用域B中创建的，那么函数A执行时形成的作用域的上一级作用域就永远是作用域B，和函数在哪里执行没关系，只和函数A创建的位置有关。

```javascript
下面例子可见，无论函数x在那个作用域中被执行，函数x的上一级作用域都永远是其创建时的作用域，也就是函数A执行时创建形成的作用域。

var i= 0;
function A(){
	var i =10;
	function x(){
		console.log(i);
	};
	return x;
}
var y = A();
y(); //  ==>y()代表A函数执行的结果也就是x函数，在全局作用域中被调用,打印10

function B(){
	var i =20;
	y();
}
B(); // ==> B()代表y(),也就等于函数x执行，此时x函数在B的作用域中被调用，打印10

```


### 全局作用域和私有作用域的执行流程
>>> 全局作用域(浏览器打开就产生了全局作用域)
1. 只要浏览器打开之后解析JS代码，首先需要创建一个代码执行的环境，全局作用域在此时就被创建出来了，也就是在栈内存中开辟了一块空间用于执行JS代码。

2. 然后在栈内存中开辟出变量存储空间和基础数据类型值存储空间

3. 变量提升和词法检测阶段(预编译阶段)

4. 自上而下正式开始执行JS代码(代码执行阶段)

>>> 函数作用域(只有函数执行才会产生私有作用域)
1. 创建函数：开辟堆内存---生成16进制地址----变量和地址进行关联

在任何一个作用域下创建一个函数，仅仅是在当前作用域中开辟一块堆内存，将函数体当做代码字符串存储在该堆内存中，然后让一个变量(函数名)指向该堆内存的内存地址。

2. 函数执行：形成函数私有作用域---变量提升&形参赋值---代码执行(遵循作用域链查找机制)

只有当函数被执行的时候，才会形成函数执行的私有作用域。
因为函数执行的本质就是将原先存储在堆内存中的代码字符串放到该函数的私有作用域中，将代码字符串解析成为JS代码自上而下执行。

+ 私有作用域中会在代码执行之前进行形参赋值和变量提升,函数的形参本质是当前私有作用域下的私有变量。
+ 然后代码自上而下执行，在执行的过程中如果遇到一个变量，就遵循作用域链查找机制查找该变量的值。

### 什么是函数的私有变量？
私有变量：在函数私有作用域中的变量存储区域存储的变量叫做私有变量。
1.函数中带var let const function声明的变量
2.函数的形参变量也是私有变量，在函数执行前会完成对于形参变量的赋值，如果没有传递实参那么值为undefined

### 函数形参当做私有变量的特殊情况
前面所学可知:
1. 函数在执行时其形参会成为当前私有作用域的私有变量并且在执行前完成形参变量的赋值
2. 外部作用域不可访问函数私有作用域中的私有变量,这是函数保护其私有变量的闭包机制决定的
3. 私有作用域中查找变量的机制是作用域链一层层向上查找的机制
4. 函数执行若干次，就形成多个互不相干的私有作用域。
5. 函数在执行时传递的实参一定是一个确定的值，如果fn(foo),那么代表的是将变量foo所存储的那个值当做实参，传递给函数的形参。传递的实参如果是基本类型值是按值传递；如果是引用类型的值等于是将该值在堆内存的引用地址当做值传递给了形参。
6. 函数return的一定是一个确定的值，如果return的是一个变量，那么本质是将这个变量存储的值return出去，这个道理和执行函数时传递的实参一定是一个值的道理相同。

注意:
1. 当函数在执行时,函数的形参接收到的实参的值是基本数据类型值,那么是按值操作的,也就是函数内部对于该值的操作互不影响.
2. 如果函数的形参接收到的实参的值是引用数据类型值,那么是按地址操作的,本质是将该引用值的堆内存地址传递给了形参。函数内部对于该形参私有变量进行操作,这种变化会同步的影响到外部全局变量。
3. 如果该私有变量在函数内部重新指向了另外一个堆内存地址，那么此时私有变量指向了新的内存地址，后续对于该私有变量的操作不会影响到外部的全局变量。

