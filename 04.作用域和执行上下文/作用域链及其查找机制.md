## JavaScript中的作用域

### 作用域是什么
浏览器作为一个安装在操作系统之上的应用程序，它内部是一个多进程架构。
一般来说，浏览器有以下这些进程组成：
1. 浏览器主进程 统一调度其他进程、浏览器UI、前进后退等
2. 渲染进程 也就是我们常说的排版引擎和V8执行引擎，JS的执行就是在渲染进程中
3. 网络进程 负责从服务器加载资源
4. GPU进程 负责硬件加速
5. 插件进程等

根据以上对浏览器进程的了解我们可以知道，浏览器不仅仅是负责JS代码执行这么一个作用，明确这一点我们再来谈谈作用域。

我们知道，浏览器从网络进程那边获取到JS脚本资源之后就需要放到渲染进程中解析执行，在执行之前首先得有一个JS代码执行的环境吧，负责代码在哪里执行呢？
所以浏览器为了让JS代码执行，会从当前内存空间中开辟一块栈内存空间，这个栈内存空间主要有两个作用：
1. 当做JS代码执行的环境，也就是我们说的主执行栈
2. 存储代码执行过程中产生的变量以及基本数据类型的值，当然还会存储引用类型值的引用地址

综上所述，我们可以将作用域这个名词解释为以下三层意思：
1. 作用域是JS代码在浏览器中执行的环境，或者说作用域是一段程序分配的栈内存空间
2. 作用域可分为全局、函数以及局部作用域，作用域还有一个名字就是执行上下文，分别是全局执行上下文和函数执行上下文
3. 作用域从内存中的变量的角度来看，也可以看做是变量可以访问的范围，局部变量可以访问全局作用域，而全局变量不可以访问局部作用域

### 作用域的分类
根据上述对于作用域的分类，我们可以把JS中的作用域分为四类：
1. 全局作用域：也就是浏览器为JS代码在一开始执行的时候分配的栈内存空间
2. 函数作用域：在代码执行的过程中，没遇到函数调用就为该函数的执行开辟一个函数作用域，和全局隔离起来保证变量互不干扰
3. 块级作用域：ES6中通过let和const声明的变量具有块级作用域
4. eval和with语句形成的增强作用域


## JavaScript中的作用域链

### 作用域链查找机制
函数在执行时会形成一个私有的函数作用域，在函数作用域中访问一个变量，首选会在当前私有作用域中查找该变量是否被定义，如果有就用当前作用域的，如果没有就向上一级的作用域中查找该变量是否被定义，一直查找到作用域的最顶端window全局作用域，如果还是没有找到那么可能会报错：xxx is not defined。这种一级一级向上查找的机制叫做作用域链查找机制。

### 查找变量上级作用域的注意点
作用域链的查找机制的关键在于如何查找上级作用域，而这个过程中需要注意一个核心点：
从函数创建的那一刻开始，该函数的作用域就已经确定，不会随着函数调用位置的不同而改变

比如当前函数A是在作用域B中创建的，那么函数A执行时形成的作用域的上一级作用域就永远是作用域B，和函数在哪里执行没关系，只和函数A创建的位置有关。

下面举例说明：无论函数x在那个作用域中被执行，函数x的上一级作用域都永远是其创建时的作用域，也就是函数A执行时创建形成的作用域。
```js
var i= 0;
function A(){
	var i =10;
	function x(){
		console.log(i);
	};
	return x;
}
var y = A();
y(); //  ==>y()代表A函数执行的结果也就是x函数，在全局作用域中被调用,打印10

function B(){
	var i =20;
	y();
}
B(); // ==> B()代表y(),也就等于函数x执行，此时x函数在B的作用域中被调用，打印10
```



## 全局作用域
全局作用域的创建时机是浏览器开始执行JS代码的那一刻，因为执行代码需要环境，需要分配内存空间，这个代码执行环境就是全局作用域。
1. 浏览器打开之后解析JS代码，首先需要创建一个代码执行的环境，全局作用域在此时就被创建出来了，也就是在栈内存中开辟了一块空间用于执行JS代码。
2. 在栈内存中开辟出变量存储空间和基础数据类型值存储空间
3. 变量提升和词法检测阶段(预编译阶段)
4. 自上而下正式开始执行JS代码(代码执行阶段)

## 私有作用域
私有作用域的创建时机是当某个函数被执行的时候，会创建一个私有的作用域。一般来说函数的创建和函数的执行是不同的：

1. 函数创建的流程
在任何一个作用域下创建一个函数，仅仅是在当前作用域中开辟一块堆内存，将函数体当做代码字符串存储在该堆内存中，然后让一个变量(函数名)指向该堆内存的内存地址。总体来说就是三步：
+ 开辟堆内存
+ 生成16进制地址
+ 变量(函数名)和内存地址进行关联

2. 函数执行的流程
只有当函数被执行的时候，才会形成函数执行的私有作用域。因为函数执行的本质就是将原先存储在堆内存中的代码字符串放到该函数的私有作用域中，将代码字符串解析成为JS代码自上而下执行，这个过程分为四步：
+ 形成函数私有作用域
+ 变量提升
+ 形参赋值，函数的形参本质是当前私有作用域下的私有变量
+ 代码执行，执行过程中遇到变量遵循作用域链进行查找


## 函数的私有变量


### 什么是函数的私有变量？
私有变量：在函数私有作用域中的变量存储区域存储的变量叫做私有变量。
1. 函数中带var let const function声明的变量
2. 函数的形参变量也是私有变量，在函数执行前会完成对于形参变量的赋值，如果没有传递实参那么值为undefined

### 函数形参当做私有变量的特殊情况
前面所学可知:
1. 函数在执行时其形参会成为当前私有作用域的私有变量并且在执行前完成形参变量的赋值
2. 外部作用域不可访问函数私有作用域中的私有变量,这是函数保护其私有变量的闭包机制决定的
3. 私有作用域中查找变量的机制是作用域链一层层向上查找的机制
4. 函数执行若干次，就形成多个互不相干的私有作用域。
5. 函数在执行时传递的实参一定是一个确定的值，如果fn(foo),那么代表的是将变量foo所存储的那个值当做实参，传递给函数的形参。传递的实参如果是基本类型值是按值传递；如果是引用类型的值等于是将该值在堆内存的引用地址当做值传递给了形参。
6. 函数return的一定是一个确定的值，如果return的是一个变量，那么本质是将这个变量存储的值return出去，这个道理和执行函数时传递的实参一定是一个值的道理相同。

注意:
1. 当函数在执行时,函数的形参接收到的实参的值是基本数据类型值,那么是按值操作的,也就是函数内部对于该值的操作互不影响.
2. 如果函数的形参接收到的实参的值是引用数据类型值,那么是按地址操作的,本质是将该引用值的堆内存地址传递给了形参。函数内部对于该形参私有变量进行操作,这种变化会同步的影响到外部全局变量。
3. 如果该私有变量在函数内部重新指向了另外一个堆内存地址，那么此时私有变量指向了新的内存地址，后续对于该私有变量的操作不会影响到外部的全局变量。

