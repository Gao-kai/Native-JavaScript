## JavaScript代码执行的大致顺序
1. 开辟栈内存形成代码执行的全局作用域(执行上下文)
2. 词法检测(预编译阶段)
3. 变量提升（预编译阶段）
4. 代码自上而下执行


## 变量提升机制

### 什么是变量提升？
当浏览器开辟出供代码执行的栈内存之后，JS代码并不会立马自上而下执行。
而是先把当前作用域中所有var声明的变量以及function声明的函数进行提前的声明和定义，这种机制就做JS执行的变量提升机制，在变量提升之后代码才开始真正的自上而下执行。所以变量提升发生在JS执行之前。

### var和function变量提升的区别
1. var声明变量提升
var声明的变量只是提前声明(decalar)，默认值为undefined，并不会给变量赋值

2. function声明的函数，不仅会进行提前声明，而且还会定义(defined),定义其实就是赋值，本质就是让该变量和某个值进行关联。因为JS中变量赋值并不是真正的赋值，而是一种变量和值产生关联的过程。

3. 只有function声明的函数才会被变量提升（声明且赋值），而var a = function (){};这样的函数表达式会被当作var声明的变量a只进行提前声明，并不会进行定义也就是变量赋值的过程。但是这种函数表达式创建函数的方法最常用，因为这种方法可以避免在函数定义之前执行函数而不报错，ES6中的箭头函数的创建方法也是参考了这种函数表达式的方式。

```js
sum(10,20);
var sum = function (n,m){
	return n+m;
}
// 以上代码执行会报错：Uncaught TypeError：sum is not a function  sum变量不是一个函数
// 因为只把var声明的变量提升到了顶部，并没有定义也就是默认值undefined
```


## 变量提升难点一：同名变量和函数重载
首先来回顾下上面说的三个变量提升的特点：
1. var声明的变量在预编译阶段只会将声明进行提升，并不会赋值；
2. function声明的变量在预编译阶段也会提升，并且还会赋值；
3. 函数表达式声明的函数和var声明一个变量没有区别，只会将声明的变量进行提升，提升到顶端之后并不会赋值

但是如果在相同的作用域中同时出现var声明、function声明以及函数表达式声明同一个变量的情况，该如何处理呢？比如下面这个经典的面试题：
```js
fn();
function fn(){console.log(1);}
fn();
function fn(){console.log(2);}
fn();
var fn = function(){console.log(3);}
fn();
function fn(){console.log(4);}
fn();
function fn(){console.log(5);}
fn();
```
仔细分析发现，这道题至少要考虑清楚三个问题：
1. 同一作用域下相同函数名的声明，其实就是函数的重载，其提升和执行的顺序是什么？
只做一次提升，也就是一次声明，然后就是多次赋值。

2. 同一作用域下var和function声明了同名变量，提升的顺序是什么？
那个声明早先提升那个，后续再去声明会被直接忽略。

3. 函数表达式和function声明的同名变量该如何确定顺序？
同上，将函数表达式看做var声明的变量即可。

下面就一一来分析和回答以上问题。
首先有一个结论：如果一个作用域中的多个函数声明的变量相等，那么只会进行一次声明，但是会进行多次赋值。
意思就是上述多个function声明，由于函数名也就是变量相等，那么看似是多次声明和赋值，其实只进行一次声明，但是会进行多次赋值。
```bash
变量区域    值区域         堆内存
 fn          AAA01     "console.log(1);"
             AAA02     "console.log(2);"
             AAA03     "console.log(4);"
             AAA04-----"console.log(5);" 
```
首先在预编译阶段发生变量提升，function声明的变量fn最先被提升到顶端，在经过连续多次的赋值之后，此时处于作用域顶端的变量fn保存的是AAA04指向的函数的值function fn(){console.log(5);}。此时的题目其实就变成了如下所示：
```js
function fn(){console.log(5);}
fn();
fn();
fn();
var fn = function(){console.log(3);}
fn();
fn();
fn();
```
你可能会疑问function fn(){console.log(1);}这些代码去哪里了呢？这是由于浏览器在执行JS代码的时候，为了性能的考虑，对于重复的函数声明会直接跳过，所以说JS中的函数是没有重载的，也就是后面的同名函数声明会覆盖前面的函数声明。

在预编译阶段遇到var fn = function(){console.log(3);}这一句代码的时候，虽然var fn会被提升到作用域顶端，但并不会发生赋值，这里需要注意下虽然var和function声明的都是fn变量并且都会被提升，但由于function声明的早，并且声明的都是变量都是fn，浏览器为了性能就会直接忽略这种对相同的变量的重复声明，直接跳过，至此预编译阶段结束。

下面开始真正执行代码，首先连着执行3次fn，也就是打印3次5。
然后遇到var fn = function(){console.log(3);}，由于var fn之前已经被提升，这里其实就是对fn变量的重新赋值，其实就是将fn变量指向了新的内存空间，也就是console.log(3)函数存放的堆内存空间。
代码继续执行，此时fn指向已经变化，再连着执行3次fn，也就是打印3次3。
所以最后就是打印5,5,5,3,3,3

## 变量提升难点二：条件语句中的提升

### 条件语句中使用var声明变量
不管条件是否成立，var声明的变量都会进行变量提升，提升至全局作用域的顶端。
这是因为只有代码真正的自上而下执行的时候才会走条件判断，但是在执行之前会先经过词法检测和变量提升阶段。
```js
console.log(a); //   undefined
if(!('a' in window)){
	var a = 13;
}
console.log(a); //   undefined
```

在上面的变量提升阶段,条件语句中的var a = 13中的a变量会被提前声明，并提升到全局作用域的顶端。
这里补充下在全局作用域下声明变量带var和不带var的一点小区别：

var a = 10语句至少代表两个意思：
1. 在全局作用域中声明了一个变量a，并赋值为10
2. 在全局window对象上添加了一个属性'a'，属性值为10

a = 10语句这种未声明就赋值只代表一个意思：
1. 在全局window对象上添加了一个属性'a'，属性值为10

所以以上题目分析得出：经过变量提升阶段之后，第一个打印a的结果是undefiend;然后判断属性'a'是否属于window为true取反为false，那么条件不满足，进入不到给a = 13赋值的条件语句中去，所以第二个a打印的结果还是undefined。


### 条件语句中使用function声明变量
在新版本的浏览器中，如果一个function声明的函数变量存在与条件语句中，那么只会发生函数的声明而不会被赋值，这是为了向ES6严谨的语法规范。
下面看一个小案例：
```js
demo(); // Uncaught TypeError: demo is not a function
if('demo' in window){
	function demo(){
		console.log(666);
	}
}
demo(); // 代码不会执行到这里
```
在上述的代码中，变量demo会进行变量提升，但是由于其处于if条件语句中，那么只会进行变量声明，也就是demo的值为undefined。
当正式执行代码的时候，demo()代表函数被调用，此时demo的值为undefined，那么程序就会报错，报错信息为Uncaught TypeError: demo is not a function

再看一个更新后的案例：
```js
console.log(demo) // undefined
if('demo' in window){
	demo() // 666
	function demo(){
		console.log(666);
	}
}
demo(); // 666
```
1. 根据前面说的条件语句中的函数声明的执行机制，变量demo会被提升到全局作用域顶端，但是不会赋值，所以第一个demo打印的结果是undefined
2. 然后又因为条件语句是一个块级作用域，在作用域中代码执行之前也会进行变量提升，这里会把函数声明demo提升到块级作用域顶端并进行赋值
3. 开始执行代码，由于使用function声明的函数在全局作用域下被声明，同时也等于在window的全局对象上添加了对应的属性，这一点和var声明的变量是类似的。所以if条件语句是成立的，此时进入到条件语句中。
4. 在进入到条件语句之后，因为在代码执行之前已经在当前作用域中完成了对于demo的赋值，所以条件语句中的demo()函数执行并不会报错，而是打印666
5. 最后一个demo()函数执行，由于demo变量已经发生了赋值，所以同样会打印666

## 变量提升难点三：立即执行函数的提升

### 立即执行函数的写法
一般情况下我们在JS中有常见的两种声明立即执行函数的写法,以下两种写法都只是执行函数，但是不会对函数的返回值做任何处理：
```js
(function(){...函数体})(); 
(function(){...函数体}());
```
其实除了常见的写法之外，还可以在一个函数声明前面加上下面四种操作符来实现一个立即执行的函数，并且这四个符号除了可以执行函数之外，还可以对函数的返回值做对应的处理，这四个符号及其效果为：
1. + 
函数的返回结果先转化为数字类型，如果是有效数字进行一元正负数学运算；如果不是直接返回NaN
2. -
同上，也是对函数的返回结果进行数学运算
3. ！
对函数的返回结果进行取反
4. ~
对函数的返回结果进行按位取反，其表现为：
所有正整数的按位取反是其本身+1的负数
所有负整数的按位取反是其本身+1的绝对值
零的按位取反是 -1

下面这行代码会先立即执行打印1，然后返回100，并对返回的结果进行一元正负运算，将100变为-100并打印出来。
```js
let res = -function(){
	console.log(1);
	return 100;
}();
console.log(res); // -100
```

### 立即执行函数的本质
立即执行函数前面加的+-!~符号以及（）等符号都有一个共同的目的，那就是让匿名函数立即执行并且符合JS中函数执行的语法规范。因为直接写function(){}();程序会报错，这里只是让函数立即执行起来。

立即执行函数可以立即执行其本质的原因就是在内部会将一个函数声明语句变为一个函数表达式，然后再去执行这个函数表达式。


### 立即执行函数不进行变量提升
只有函数声明和函数表达式会进行变量的提升，立即执行函数不会进行变量提升，也没办法提升，立即执行函数没都是匿名函数。
以下面这个综合考察变量提升的题目为例：
```js
f = function(){return true;}
g = function(){return false;}

~function(){
	if(g() && [] == ![]){
		f = function(){return false;}
		function g(){return true;}
	}
}();

console.log(f()); // Uncaught TypeError:g is not a function。
console.log(g());
```

我们从上到下依次进行分析：
首先顶部的g和f都没有声明就赋值，意思就是：
```js
window.f = function(){return true;}
window.g = function(){return false;}
```
然后接下来执行立即执行函数,在函数作用域中先进行变量提升，而因为存在与if条件语句中的函数声明只会将变量提升到当前作用域的最顶端，也就是会提升到立即执行函数作用域内部的顶端，此时变量g就被提升，但是不会发生赋值，值为默认的undefined。

变量提升结束之后开始执行代码，首先判断条件g() && [] == ![]是否成立，由于此时函数作用域下的g的值为undefined，那么程序就会报错，后续的代码也会中止执行。报错信息为：Uncaught TypeError:g is not a function。

只需要将g() && [] == ![]修改为window.g() && [] == ![]，那么程序就可以正常执行。
```js
f = function(){return true;}
g = function(){return false;}

~function(){
	if(window.g() && [] == ![]){
		f = function(){return false;}
		function g(){return true;}
	}
}();

console.log(f()); // true
console.log(g()); // false
```

### 题目
求以下代码执行的结果：
```js
var name = 'tom';
(function(){
	// var name; name undefined
	if(typeof name === 'undefined'){
		var name = 'jack';
		console.log('GoodBay' + name); // GoodBaytom
	}else{
		console.log('hello' + name);
	}
})();
```

对于全局作用域来说，在全局下执行的立即执行函数不会被当做function声明的函数在全局执行栈中进行提升
对于立即执行函数自己的执行作用域来说，它自己执行时形成的私有函数作用域会进行变量提升。


## 变量提升难点四：变量连续赋值和连续声明的提升
首先来看一道题目：
```js
console.log(a,b); 
var a = 12,
	b = 12; // 等价于var a = 12;var b = 12;  


function fn(){
	console.log(a,b);
	var a = b = 13; // 等价于b = 13;var a = 13; 先给b赋值，然后声明一个变量a并进行赋值
	console.log(a,b);
}
fn();
console.log(a,b);
```

从上而下依次分析：
首先在全局作用域中进行变量提升，使用逗号操作符进行连续的变量声明，只不过是一种简便写法，其本质就是：
```js
var a = 12;
var b = 12;
```
此时将var a和var b依次进行提升，但不赋值，所以打印两个undefined。

然后执行fn函数，在fn函数作用域中进行变量提升，这里使用了变量的连续赋值，其本质之前说过，其实就是：
```js
b = 13;
var a = 13;
```
就等于b变量是未经声明就赋值，将全局对象上的b变量赋值为13，此时全局的b值修改为13。
然后将var a提升到函数作用域顶端，所以首先打印a为undefined，b为全局的13.
第二个函数内部的console打印，此时a已经在局部被赋值为13，所以a和b都是13.

最后的console打印，a的值还是全局的12，b的值已经是全局的13了，所以依次打印：
```js
undefined undefined
undefined 13
13 13
12 13
```

## 变量提升练习题一
```js
var a = 100;
funtion fn(a){
	console.log(a);
	var a = 200;
	function  a(){};
}
fn(a);
```

1. 函数内部私有作用域栈执行，先是形参赋值后才是变量提升
2. 形参赋值之后，var声明的同名变量a就不再进行提升了，也可以看做无效声明
3. 同样，function声明的同名函数变量a也不再提升了，但是赋值必须要进行，所以变量a最终会被赋值为字符串'f a(){}'

## 变量提升练习题二
```js
var a = 0,
	b = 0;
function A(a){
	A = function(b){
		alert(a + b++);
	}
	alert(a++);
}
A(1); // 1
A(2); // 4
```

分析流程：(函数重构)
```bash
GO:{
	a:0,
	b:0,
	A:AF001 => function A(a){...函数体}
	  BF001 => function (b){...函数体} 
}

A(1)执行时的作用域AO:{ AF001
	新参赋值 变量提升
	a: 1,2
	第一次A执行,给全局window上添加了一个A属性,重写了之前的A函数
	也就是将之前指向AF001修改为指向BF001
	所以全局变量A始终指向函数BF001，所以A(1)执行时的作用域不销毁
}

先弹出a的值为1，然后将a的值加1 

A(2)执行时的作用域AO:{ BF001 其上级作用域是去其定义时候的A（1）执行时的作用域，因为只有A（1）执行了才有了重构函数A，才在堆内存中创建了小函数，所以无论它在哪里执行，其上级作用域是创建堆内存的时候就确定的。
	新参赋值 变量提升
	b:2
},
弹出弹框 a + b++ = 2 + 2 = 4

```