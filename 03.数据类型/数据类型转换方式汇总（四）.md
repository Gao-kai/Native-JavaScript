## 隐式转换
除了调用Number、String等强制转型函数的时候会发生数据类型转换之外，在使用JS中的操作符进行运算的时候，其实也会发生数据类型的转换，这就是JS中数据类型的隐式转换。

## +号的隐式转化（基于toPrimitive方法的底层机制进行比较）

## 类型转化之==比较运算符（以数字优先）

### 1. 总体转化思路
1. 如果都是对象，那么比较对象的引用地址是否相等
2. 如果有一个是对象，那么先将引用值基于toPrimitive(value,Number)的规则转化为原始值，然后再遵守两个基本类型值比较的规则进行比较。为了快捷起见，可以直接跳过valueOf方法(因为一般情况下valueOf返回的是引用值本身)，直接调用引用值的toString方法转化为字符串基本值，拿到这个字符串基本值再和比较双方的另外一个基本值进行比较即可。
3. 比较特殊的是如果任意一个值为布尔值，优先将布尔值转化为数值再比较是否相等，也可以说如果出现!运算符，那么首先要做的就是直接将其转化为布尔值然后再直接转为数值。

### 2. 原始值比较规则
1. 如果任意一个值为布尔值，优先将布尔值转化为数值再比较是否相等，布尔值转数字的优先级在字符串转数字之前
2. 如果任意一个值为字符串一个为数字，则需要将字符串转为数值，然后进行比较
3. 如果基本值为null或undefiend，那么遵循undefiend除了自身和null之外，不和任何值相等。也就是：
```js
undefined == null       true
undefined == undefined  true
null == null            true
```
4. 如果有任一操作数是 NaN,那么一定返回false。因为NaN和任何数比较都是false


### 题目
```js
[] == [] 两边都是引用值，引用地址不同返回false

![] == [] 
有!运算符，先把左边转为布尔值false，然后接着转为0，数值0和引用值[]比较，获取引用值[]的toPrimitive(value,String)方法转为空字符串'',然后数值0和空字符串比较，空字符串进一步转化为数值0，0==0返回true
```

```js
[] == false 同上 返回true

![]==false 先把![]转化为布尔值为false false == false 结果为true
```

```js
!{} == []
```
+ 有!运算符,先把左边转为布尔值false，然后接着转为0
+ 变成数值0 == []的比较，获取引用值[]的toPrimitive(value,String)方法转为空字符串''
+ 变成数值0 == ""的比较，数值和字符串比较的时候需要将字符串转为数值，空串转为0
+ 变成数值0 == 0的比较，返回true