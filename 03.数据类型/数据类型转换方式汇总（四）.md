## 隐式转换
除了调用Number、String等强制转型函数的时候会发生数据类型转换之外，在使用JS中的操作符进行运算的时候，其实也会发生数据类型的转换，这就是JS中数据类型的隐式转换。

## +号的隐式转化（基于toPrimitive方法的底层机制进行比较）

### 场景
1. +号当做一元正负运算符
会将+号后面的值直接转化为数字，这也是最快速的将对象转化为数字的方法之一，因为它不会对数值执行过多操作，要比直接Number()方法还要快。

2. +号当做字符串级联运算符
+号两端有一个是字符串，那么进行字符串级联运算
+号两端有一个是引用值，此时需要基于toPrimitive(value,Number)进行转化，也就是需要先调用valueOf后调用toString方法拿到基本值，然后进行字符串连接即可

### 日期时间对象Date在进行+号运算符隐式转化时的特殊情况
var date = new Date(); 
date实例的valueOf方法会返回一个1970-01-01距今的时间戳，该时间戳是数字类型的1622341901750
date实例的toString方法会返回一个本地日期时间字符串："Sun May 30 2021 10:31:16 GMT+0800 (中国标准时间)"

console.log(+date);     ===> 1622342082590
前有+号，代表一元正负运算符，此时需要将日期时间对象转化为数字，所以先调用valueOf方法得到时间戳，时间戳本身就是数字类型，所以直接返回即可。
console.log('' + date); ===> "Sun May 30 2021 10:31:16 GMT+0800 (中国标准时间)"
+号一边为字符串，一边为日期时间对象date，此时需要将日期时间对象转化为字符串，所以先调用toString方法得到本地日期时间格式的字符串，并将该字符串和+号前面的字符串相连接。




## 类型转化之==比较运算符（以数字优先）

### 1. 总体转化思路
1. 如果都是对象，那么比较对象的引用地址是否相等
2. 如果有一个是对象，那么先将引用值基于toPrimitive(value,Number)的规则转化为原始值，然后再遵守两个基本类型值比较的规则进行比较。为了快捷起见，可以直接跳过valueOf方法(因为一般情况下valueOf返回的是引用值本身)，直接调用引用值的toString方法转化为字符串基本值，拿到这个字符串基本值再和比较双方的另外一个基本值进行比较即可。
3. 比较特殊的是如果任意一个值为布尔值，优先将布尔值转化为数值再比较是否相等，也可以说如果出现!运算符，那么首先要做的就是直接将其转化为布尔值然后再直接转为数值。

### 2. 原始值比较规则
1. 如果任意一个值为布尔值，优先将布尔值转化为数值再比较是否相等，布尔值转数字的优先级在字符串转数字之前
2. 如果任意一个值为字符串一个为数字，则需要将字符串转为数值，然后进行比较
3. 如果基本值为null或undefiend，那么遵循undefiend除了自身和null之外，不和任何值相等。也就是：
```js
undefined == null       true
undefined == undefined  true
null == null            true
```
4. 如果有任一操作数是 NaN,那么一定返回false。因为NaN和任何数比较都是false


### 题目
```js
[] == [] 两边都是引用值，引用地址不同返回false

![] == [] 
有!运算符，先把左边转为布尔值false，然后接着转为0，数值0和引用值[]比较，获取引用值[]的toPrimitive(value,String)方法转为空字符串'',然后数值0和空字符串比较，空字符串进一步转化为数值0，0==0返回true
```

```js
[] == false 同上 返回true

![]==false 先把![]转化为布尔值为false false == false 结果为true
```

```js
!{} == []
```
+ 有!运算符,先把左边转为布尔值false，然后接着转为0
+ 变成数值0 == []的比较，获取引用值[]的toPrimitive(value,String)方法转为空字符串''
+ 变成数值0 == ""的比较，数值和字符串比较的时候需要将字符串转为数值，空串转为0
+ 变成数值0 == 0的比较，返回true