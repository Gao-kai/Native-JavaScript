## 前因
之所以专门来学习下parseInt和parseFloat这两个Number类上的静态方法，是由我最近看到的一道面试题引起的，这道题目要求我们输出以下代码运行之后的返回值：
```js
[1,2,3].map(parseInt);
```
在这里我们先暂时放下这道题，等深入了解了parseInt方法的详细用法之后回过头来解决这个问题。

## parseInt(value,radix)详解

### 1. 语法功能
praseInt方法用于将任意类型的值按照给定或默认的基底，首先将这个值解析成为数字，然后将这个数字按照给定的基底转化为10进制的整数，如果解析异常直接返回NaN。

praseInt方法绝大多数情况下都是用于将字符串解析为整数的，比如将'15px'解析为15就可以直接使用该方法，但praseInt方法也是可以解析其他类型的值的，只不过会调用这些值的toString方法。

praseInt函数的返回值一定是Number类型的，要不是一个有效数值要不就是一个NaN。

### 2. 解析机制
praseInt方法解析值分为两步，并且有着比Number转型函数更加严格的规则：
+ 如果值为非字符串类型，那么会调用这个值的toString方法转化为字符串，然后进行下一步；
+ 如果值为字符串，那么解析流程如下：
1. 该字符串是否有前导的空格，如果有忽略这些空格
2. 然后从该字符串的最左边字符开始依次进行解析，如果该字符串的第一个字符为非有效数字，那么就停止解析直接返回NaN
3. 如果解析的是一个有效数字，那么会将其转化为数字，然后依次向右解析直到结束
4. 如果在解析的过程中遇到一个非有效数字，那么理解停止解析，返回当前已经解析的结果节课

### 3. 对比Number转型函数差异
通过对praseInt和Number强制转型函数的解析规则我们可以知道,两者的区别主要在于：
praseInt是对参数字符串自左到右进行逐个的查找，尽可能的解析出有效字符后返回，如果第一个字符就是非有效字符直接返回NaN;
Number转型函数是对整个参数字符串进行整体的查找，只要有一个是非有效字符就返回NaN
关于两者解析规则一个 有趣的例子是：
```js
praseInt(''); // NaN 因为第一个字符是空串是非有效字符 直接返回NaN
Number(''); // 0 Number转型函数在遇到空串的时候会返回0，而不是NaN
```

### 4. radix基底
parseInt方法的第二个参数一般容易被我们忽略，也就是基底radix。
基底radix的作用是在将参数解析为有效数值之后，把这个有效数值看做radix进制的数字，进一步转化为10进制的整数之后返回。比如下面这个代码的意思就是把字符串'11001101'先解析为数字11001101，然后将这个数字当做2进制的值转化为10进制的数，返回205。

```js
parseInt('11001101',2); // 205
```
### 5. 基底radix导致的NaN问题
其实，涉及到radix的适合，parseInt方法很容易返回NaN的结果，下面是需要注意的地方：

1. radix为0、为undefined的情况
如果radix的值为0或者省略没有传递为undefined的时候，此时radix的值会根据前面解析的字符串的值来确定最终radix的值，具体规则是：
+ 如果字符串以0x或者0X开头，那么会认为这是一个16进制的数字，此时radix的值为16
+ 如果字符串以0开头，那么会认为这是一个8进制的数字，此时radix的值为8.由于不同浏览器在这里的实现不一样，所以再使用parseInt的时候最好要指定radix的值，否则会出现意外的情况。
+ 如果字符串除了以上两种情况另外，那么radix的值就被认为是10.

2. radix的取值超出边界情况
radix的取值范围是2-36，如果在调用parseInt方法的时候传入的值不在这个范围内，那么可以返回NaN

3. radix进制异常的情况
如果字符串解析之后的数值中第一个数值（必须是从左到右第一个）大于等于传入的radix，此时也可以直接返回NaN。比如：
```js
parseInt('600',5); // NaN 5进制的数字中第一个值不可能大于5
parseInt('456',5); // 4 解析到4的时候是符合要求的，但是到5之后不符合要求
```

## 解决问题
1. 求[1,2,3].map(parseInt)的值。
```js
const arr = [1,2,3];
const parseInt = (value,radix)=>{
	return Number.parseInt(value,radix);
}
let res = arr.map((value,radix)=>{
	return Number.parseInt(value,radix);
})
/* 
	Number.parseInt(1,0); // radix为0 默认为10进制 返回1
	Number.parseInt(2,1); // radix为1 范围2-36 返回NaN
	Number.parseInt(3,2); // radix为2 不可能有2进制表示的3 返回NaN
 */
console.log(res); // [1,NaN,NaN]
```

2. 求["10","10","10","10","10"].map(parseInt)的值
按照上面一样的思路，可以得出其实就是在求：
```js
Number.parseInt(10,0); // radix为0 默认为10进制 返回10
Number.parseInt(10,1); // radix为1 1不在范围2-36中 返回NaN
Number.parseInt(10,2); // radix为2 将10看做2进制转化为10进制为2
Number.parseInt(10,3); // radix为3 将10看做3进制转化为10进制为3
Number.parseInt(10,4); // radix为4 将10看做4进制转化为10进制为4
```
## parseFloat(str)方法
功能：将一个字符串参数转化为对应的浮点数
返回值：返回一个数值或者NaN
注意：
1. parseFloat只会解析到第一个小数点，遇到第二个小数点不会再解析
parseFloat('0.223.132')   0.223

2. 和上面一样，参数str的前后所有空格都会被忽略
3. 和上面一样，如果参数str不是字符串，那么需要先转化成为字符串值然后进行解析
