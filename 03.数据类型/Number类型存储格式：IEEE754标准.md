## Number类型存储格式：IEEE754标准

### 1. 什么是IEEE754标准?
IEEE754的中文名叫做计算机二进制浮点数算术标准。
计算机在存储浮点数的时候，为了解决有些浮点数的时候需要将10进制的浮点数转化为2进制数(0和1组成)存储的时候出现无限循环的情况，计算机不可能无限制的使用存储空间去存储无限循环的数字，所以IEEE754标准针对这种情况就出台了4种表示浮点数数值的方式：
+ 32位单精度
+ 64位双精度
+ 延伸单精确度
+ 延伸双精确度

### 2. ECMAScript中Number的存储格式
ECMAScript标准规定Number类型采用IEEE754标准来表示整数和浮点数，并且采用其中的64位双精度格式来存储一位浮点数。

### 3. IEEE754标准存储浮点数过程
IEEE754标准认为，任何一个浮点数(Value)都可以被抽象表示为下面的公式来表示：
```bash
Value = sign * exponent * fraction
// sign是符号位，表示正数还是负数
// exponent表示指数
// fraction表示分数
```
上面这个公式看起来很抽象，我们举例说明：

1. 存储10进制数字为10进制格式
假设10进制数字-1020采用以上公式存储，那么可以得出：
```js
-1020 = -1 * 10^3 * 1.02
```
最终，计算机需要存储sign为-1，exponent为10^3，fraction为1.02

2. 存储10进制数字为2进制格式
我们知道，计算机的底层存储都是2进制，也就是10进制数字最终都会先被转化为2进制数字然后再进行存储。但是这里需要明白将一个10进制的数字0.1转化为2进制的过程中，会出现无限循环的情况。

比如将10进制的数字0.1转化为二进制存储，求得0.1的二进制表示为：0.0001100110011001100110011001100110011001100110011001101...，出现了无限循环的情况，此时套用公式可得：
```js
0.1 = 1 * 2^-4 * 1.1001101...
```
最终，计算需要存储sign为1，exponent为2^-4，fraction为1.1001101

### 4. 公式抽象表达
在明白上了上诉这个公式最基本的转化过程之后，IEEE754标准进一步认为，由于所有数字都会在底层被存储为二进制的形式，那么我们只做二进制的科学计数法表示即可，这个Value公式可以被进一步表示为：
```bash
Value = (-1)^Sign * 2^exponent * (1+fraction)
```
并且进一步认为，如果所有的浮点数都可以采用这个公式存储，那么计算机只需要存储变化的部分，对于公式中公共的不变的部分就不应该存储，毕竟计算机的存储空间是有限的，要尽可能的多想办法去多存储一些值。

下面以0.1的二进制数0.0001100110011001100110011001100110011001100110011001101...的存储为例，详细解读下这个公式的组成部分。
1. 第一部分 (-1)^Sign
 (-1)^Sign表示一个数的符号位，如果存储的Sign为0，那么代表是一个正数，如果为1则是负数。
 
2. 第二部分 2^exponent
如果计算机当前存储的浮点数为100.75，那么100.75转化为二进制表示为：1100100.11。然后按照此二进制的科学计数法进行表示为,此时的指数部分为6，是一个正数。
```js
Value = (-1)^0 * 2^6 * (1+0.10010011)
```
而如果计算机当前存储的浮点数是0.1，那么转化为二进制的科学计数法的表示如下，此时的指数部分为-4，是一个负数。
```js
Value = (-1)^0 * 2^-4 * (1+0.1001101)
```

所以我们首先得出第一个结论，指数的部分exponent的值有可能为正数，也有可能为负数。当浮点数转化为二进制之后还是小于1，那么此时的指数部分就是一个负数。

明确这一点之后，再来探讨exponent的值的大小。假设计算机分配了8位内存来存储这个exponent的值，那么：
+ 假设存储前的十进制的数全部都是正数，那么此时储存的值的范围是 0 ~ 254
+ 假设存储前的十进制的数有正数有负数，那么此时存储值的范围就是 -127~127。
+ 我们在存储的时候，把要存储的数字加上 127，这样当我们存 -127 的时候，我们存 0，当存 127 的时候，存 254，这样就解决了存负数的问题。对应的，当取值的时候，我们再减去 127。

但是，计算机在实际存储的时候，不会直接存储一个exponent，而是存储exponent + bias，当计算机分配了8位内存空间的时候，这个bias的值就是127

3. 第三部分 1+fraction
因为所有的浮点数都可以表示为 1.xxxx * 2^xxx 的形式，前面的一定是 1.xxx，那干脆我们就不存储这个 1 了，直接存后面的 xxxxx 好了，这也就是 Fraction 的部分。

### 5. 存储位数的分配

根据上面的描述我们知道，当采用IEEE754标准的64位双精度规格来存储一个浮点数的时候，我们只需要存储变化的fraction、exponent+ bias以及Sign三个值就可以了，但它们三个各占多少位来存储呢？

1. Sign：符号位占1位，0表示正数，1表示负数
2. exponent + bias：用11位存储，对于11位来说补位bias的值就是2^(11-1) - 1，也就是 1023。
3. fraction：用52位存储尾数位，超过52位之后的会截断。

下面我们再来完整的分配下0.1浮点数存储的过程：
0.1的二进制是：0.0001100110011001100110011001100110011001100110011001101
二进制的科学计数法表达为：
```js
0.1 = 1 * 2^-4 * 1.1001101...
```
1. 符号位是正数，存0即可。
2. 指数位E+bias，已知E的值为-4，bias阶码的值是1023，所以真正存储的值是1019，转化为二进制表示为1111111011只有10位， 不满11位所以在前面补0为：01111111011
3. 尾数位由于无限循环的关系，所以只存储前52位即可，为：1001100110011001100110011001100110011001100110011010
所以最终0.1在计算机中的64位存储为：
```js
0 01111111011 1001100110011001100110011001100110011001100110011010
```
### 6. 0.1+0.2不等于0.3的问题
通过以上的学习可以很清楚的知道，由于ECMA规范选用的规范是IEEE754的64位双精度浮点数规范，计算机在将十进制的浮点数0.1和0.2转化为二进制存储的时候，会出现无限循环的情况，而计算机不能无限制的存储，所以在尾数存储的时候发生了精度的丢失，从而在计算的时候出现计算结果和逾期不匹配的情况。
