/* 
    把一个很大的数字从右向左，三位数字加一个逗号进行分隔，所以称之为千分符
    如果不满3位就不进行分隔
    eg: 15847863521 => "15,847,863,521"
*/

/* 
    1. 不使用正则 使用从后向前遍历 不断的切割原始字符串 拼接逗号即可
*/
function millimeter(number){
    number = number.toString();
    let result = "";
    // 不断的从后向前切割字符串 直到原始字符串长度小于3
    while(number.length > 3){
        let sub = number.slice(-3);

        // 拼接结果
        result = ',' + sub + result; // ,521 => ,863,521

        // 修改原始字符串等于切割后的前半部分
        number = number.slice(0,-3);
    }

    result = number + result;
    return result;
}

console.log(millimeter(15847863521)); // 15,847,863,521
console.log(millimeter(123));

/* 
    2. 设置条件的正向预查
     ?=: 正向预查，设置一个正向条件，只要条件符合啥，但是正向预查这个位置只匹配不捕获
     ?！: 设置条件 设置一个反向条件，只要条件不符合啥，只匹配不捕获
     ?: 

     (?=(\d{3})+$) 只是一个限定条件
     1到多组 必须以3位数字结尾的字符
     从后向前匹配
*/

var num = "15847863521";
var reg = /\d{1,3}(?=(\d{3})+$)/g;
console.log(num.match(reg)); // [ '15', '847', '863' ]

num = num.replace(reg,function(match){
    return match + ',';
})
console.log(num);

/* 
    正则表达式的前瞻性和后顾性

    1. 对于正则引擎来说，对于一段文本，文本的开头往往称为前面，但是正则引擎正好相反，把文本结尾称为前；而将文本的开头称之为后。
    已经解析过的字符，就落在屁股后面了，那就是后；还未解析的字符，就还在自己前面，那就是前

    2. 正向肯定预查 (?=条件)和正向否定预查（?!条件）
    正向肯定预查就是前瞻的意思，也就是在正则匹配到某个字符的时候，具有前瞻性的先把前面尚未解析过的文本预先看下是否符合?=后面的条件
    正向否定预查就是前瞻的意思，也就是在正则匹配到某个字符的时候，具有前瞻性的先把前面尚未解析过的文本预先看下是否不符合?=后面的条件

    3.反向肯定预查 (?<=条件)和反向否定预查（?<!条件）
    反向肯定预查就是后顾的意思，也就是在正则匹配到某个字符的时候，回过头来看看已经解析过的文本是否符合？！后面的条件
    反向否定预查就是后顾的意思，也就是在正则匹配到某个字符的时候，回过头来看看已经解析过的文本是否不符合？！后面的条件


    另外一种说法：
    1、正向肯定预查 (?=pattern) 表示的是从其当前位置开始，预测后面的字符串必须匹配上pattern
    2、正向否定预查 (?!pattern) 表示的是从其当前位置开始，预测后面的字符串必须匹配不上pattern
    3、反向肯定预查 (?<=pattern) 表示的是从其当前位置开始，预测前面的字符串必须匹配上pattern
    4、反向否定预查 (?<!pattern) 表示的是从其当前位置开始，预测前面的字符串必须匹配不上pattern


    以上所有预查都是只匹配不捕获
    所有预查都是不会真正的消耗字符，也不会发生实际的捕获或匹配，预查规则只是为了限制前面或者后面匹配的规则，不占用匹配的字符
*/


/* 
    1. 写一个用户名的正则，要求必须包含字母和数字，并且长度在4-8位
*/
var reg = /^[a-zA-Z0-9]{4,8}$/;
// 这个正则有可能出现全部是数字或者全部为字母的匹配成功
console.log(reg.test(12345678));
/* 
    (?![a-zA-Z]+$) 正向否定预查 预测从开始位置到结尾你不能全部是字母
    (?!(\d)+$) 正向否定预查 预测从开始位置到结尾你不能全部是数字
    [a-zA-Z0-9]{4,8} 这个才是真正的要匹配的内容，前面只是两个预查限制
*/
var reg = /^(?![a-zA-Z]+$)(?!(\d)+$)[a-zA-Z0-9]{4,8}$/;
console.log(reg.test(12345678)); // false


/* 
    例子
*/
// 正向肯定预查 表示在匹配到windows之后，预测后面的字符必须是98|8|10|11之一，否则匹配失败。
var reg = /windows(?=98|8|10|11)/;
console.log(reg.test('windows98')); // true
console.log(reg.test('windows08'));  // false

// 正向否定预查 表示在匹配到windows之后，预测后面的字符必须不能是98|8|10|11之一，否则匹配失败。
var reg = /windows(?!98|8|10|11)/;
console.log(reg.test('windows98')); // false
console.log(reg.test('windows08')); // true

// 反向肯定预查 表示在匹配到windows之后，预测前面的字符必须是98|8|10|11之一，否则匹配失败。
var reg = /(?<=98|8|10|11)windows/;
console.log(reg.test('11windows')); // true
console.log(reg.test('11windows98')); // // true

// 反向否定预查 表示在匹配到windows之后，预测前面的字符必须不是98|8|10|11之一，否则匹配失败。
var reg = /(?<!98|8|10|11)windows/;
console.log(reg.test('11windows')); // false
console.log(reg.test('11windows98')); // // false