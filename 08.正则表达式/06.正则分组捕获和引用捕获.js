/* 
    1.正则的分组捕获
    基于小括号可以进行分组捕获的特点，采用exec方法或者match方法进行分组捕获
    分组捕获的结果中：
    第一项为大正则匹配的结果
    后面每一项依次对应每一个小括号匹配的结果
*/

var idReg = /^(\d{6})(\d{4})(\d{2})(\d{2})\d{2}(\d)(\d|X)$/;
console.log(idReg.exec("622429199702012413"));

/* 
    [
        '622429199702012413',
        '622429',
        '1997',
        '02',
        '01',
        '1',
        '3',
        index: 0,
        input: '622429199702012413',
        groups: undefined
    ]
*/

/* 
    2. 分组捕获时的只匹配不捕获 ?:
    还是以上面这个身份证号码的正则来看，现在我们不需要捕获最后一项是数字还是X，因为对我们没有意义。
    所有我们现在的需求是不对最后一位进行捕获，但是你不能直接去掉小括号，因为|或服务会造成正则匹配的优先级的紊乱，所以还得使用小括号提高优先级
    幸好，我们可以使用?:来告诉正则，当然某个小括号内的字符只进行匹配，而不需要捕获
*/
var idReg = /^(\d{6})(\d{4})(\d{2})(\d{2})\d{2}(\d)(?:\d|X)$/;
console.log(idReg.exec("622429199702012413"));
/* 
[
  '622429199702012413',
  '622429',
  '1997',
  '02',
  '01',
  '1',
  index: 0,
  input: '622429199702012413',
  groups: undefined
]

*/

/* 
    3. match在分组捕获时的缺点
    要求实现一个正则，既可以捕获到{数字}这个部分，也可以捕获到单独的数字012，比如执行一次捕获，可以获取到"{0}"，还可以获取到0
    让一个正则循环的对字符串进行匹配，并且获取到每一次匹配的大正则匹配结果和小分组匹配结果。
    match执行一次的话是获取不到小分组匹配结果的，如果要实现只能依靠exec+while。
*/

var str = "{0}年{1}月{2}日";
var reg = /\{(\d+)\}/g;

// reg为全局匹配，执行match方法进行全局捕获，可以得到大正则捕获的结果数组：[ '{0}', '{1}', '{2}' ]
console.log(str.match(reg)); 

// 但是里面小分组的0\1\2没有捕获到，这就是match方法的缺点。只能捕获大正则的所有匹配结果，更加小的分组匹配结果无法获取，还得依靠while循环和exec方法来实现：
let bigCapture = [];
let smallCapture = [];
let res = reg.exec(str);
while(res){
    bigCapture.push(res[0]);
    smallCapture.push(res[1]);
    res = reg.exec(str);
}
console.log(smallCapture,bigCapture);[ '0', '1', '2' ] [ '{0}', '{1}', '{2}' ]


/* 
    4. 小括号的第三个作用：分组引用
    分组引用就是使用"\数字"代表和对应分组出现一模一样的内容，多用在匹配叠词上
*/
var arr = [
    "book",
    "door",
    "food",
    "look",
    "moon"
]

// 匹配四个字母的单词，并且中间两个单词值完全相同
// 使用当前正则不行，因为无法保证中间两个单词值完全一致
var reg = /^[a-zA-Z][a-zA-Z][a-zA-Z][a-zA-Z]$/;
console.log(reg.exec(baba));

// 使用分组引用实现和上一个分组值完全一致
var reg = /^[a-zA-Z]([a-zA-Z])\1[a-zA-Z]$/;
console.log(reg.exec("baba")); // null


/* 
    5. 正则捕获的贪婪性
    默认情况下，正则捕获的时候是按照当前正则所匹配的最长最多的结果来获取的，比如下面这个例子：
*/
var reg = /\d+/g;
var str = "111哈哈222嘻嘻333";
console.log(str.match(reg)); // [ '111', '222', '333' ];
/* 
    这里有个疑问：既然\d+代表1到3位的数字，那么一开始捕获一个1也可以，11也可以，111也可以。
    但为什么捕获的结果总是最多的111呢？这就是正则捕获默认的贪婪性，它总是尽可能多的去匹配符合条件的字符。
    如果我们要取消正则捕获的贪婪性，就想每次捕获只捕获到最少符合条件的字符就返回，该怎么做呢？
    答案就是在原本的量词元字符后面加一个?，代表取消正则捕获的贪婪性
    我们发现将每一个最短匹配结果都单独捕获到了
*/
var reg = /\d+?/g;
var str = "111哈哈222嘻嘻333";
console.log(str.match(reg));  //[ '1', '1', '1', '2', '2', '2', '3', '3', '3'] 



/* 
    正则表达式中问号?的作用：
    1. 跟在普通元字符后面，代表出现0次或者1次
    2. 跟着量词元字符后面，代表取消正则捕获的贪婪性，总是按照最短结果捕获
    3. 在小括号的开头(?:)，代表对该分组规则只匹配不捕获
    4. (?=) 正向预查
    5. (?!) 负向预查

    正则表达式中小括号()的作用：
    1. 提高优先级，尤其是在|运算符的时候
    2. 分组捕获
    3. 分组引用
*/