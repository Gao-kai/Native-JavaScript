## 内存泄漏是什么
我们都知道程序的运行需要内存，对于持续运行的程序必须释放不再用到的内存，否则会导致内存的占用越来越高，导致应用程序的崩溃。所以就有了垃圾回收机制，基于垃圾回收机制可以将哪些不再使用的内存进行回收整理，并分配给后续程序运行过程中的变量使用。

但是，有些情况下程序已经分配的内存会由于某些原因未释放或者无法释放，造成系统内存的浪费，当这种情况越来越多的时候，也会导致应用的卡顿或者系统的崩溃，我们把这种不能用到的内存没有及时释放的现象叫做内存泄漏。

## 内存泄漏的场景

### 1. 意外的全局变量
一般情况下函数执行分配的执行上下文，会由于函数的执行结束从执行栈的栈顶弹出，函数及其内部私有变量占有的内存会被及时的通过垃圾回收机制所进行回收。

但是如果是一个全局变量，由于全局变量都是挂载到window全局对象上的，所以GC不会对这部分全局变量进行回收，也就是说哪怕以后不会再使用这些全局变量，但是垃圾回收机制也无法正确回收，从而导致内存泄漏。

通常情况下我们不会手动去定义一个全局变量，引起内存泄漏的全局变量大多数情况下是通过意外的某种编码方式引起的，比如：
+ 未经声明就赋值的变量，会被当做全局变量，函数demo执行完成之后作用域销毁但是a变量占有内存无法被回收,这种情况可以使用let或者const声明变量来解决
```js
function demo(){
	a = 100;
}
demo();
```

+ 函数执行过程中给this赋值，恰好this为全局变量，这种情况可以使用严格模式来解决
```js
function demo(){
	this.a = 100;
}
demo();
```

### 2. 遗忘的定时器
setTimeout 和 setInterval 是由浏览器专门线程来维护它的生命周期，当某个页面使用了定时器而该页面销毁的时候，没有使用clear方法去清除对应的定时器，那么也会造成内存泄漏。

你可能会好奇：我在首页注册了一个定时器，我现在注销了首页切换到了购物车页面，那么首页注册的定时器难道不会自己注销吗？

答案是不会。这是因为setTimeout 和 setInterval定时器的生命周期和页面的生命周期并不是一回事，定时器的生命周期并不挂靠在页面上。所以当页面注册的定时器没有被及时销毁，那么恰好定时器内部的回调函数内又引用了当前页面的某个变量或者DOM元素时，即使页面销毁也会导致定时器内保持着对原来页面中变量的引用而无法被完全回收。

当我们多次反复的打开关闭该页面的时候，就会形成多个无法被回收的内存空间，最后导致内存泄漏越来越多，最终导致程序的崩溃。

解决方法就是在当前页面注册的定时器在合适的时机进行清除。
```js
let obj = getData(); // obj内存无法被释放

setTimeout(()=>{
	let el = document.getElementById('app');
	el.innerHtml = obj; // 定时器内部回调中保持着对DOM元素和obj对象的引用
},1000)
```

### 3. 闭包
关于闭包会引起内存泄漏我们说过很多次，但是多数情况下我们在程序中之所以使用闭包就是为了利用闭包保护函数作用域中某个私有变量不会被垃圾回收机制回收，这本身就是闭包的特点也就是将全局变量保护为私有变量。

同时我们也要知道，如果在某个时刻不需要保持对原函数作用域中私有变量的引用时，需要手动将其指向null以便于垃圾回收机制进行回收。

### 4. JS中未清理DOM元素的引用
一个DOM元素的生命周期取决于其是否挂载在DOM树上，当从DOM树上移除的时候，垃圾回收机制就可以对这个DOM元素进行回收。

但是如果我们的JS代码中某个变量保持了对于DOM元素的引用，那么还需要解除JS变量对DOM元素的引用，此时DOM元素才算被完全释放，否则垃圾回收机制是无法正确回收的。

```js
const refA = document.getElementById('refA');
document.body.removeChild(refA); // dom删除了
console.log(refA, 'refA'); // 但是还存在引用能console出整个div 没有被回收
refA = null;
console.log(refA, 'refA'); // 解除引用
```

### 5. 未清理的回调函数
回调函数在JS中的应用是十分广泛，比如AJax请求数据然后等待数据返回之后执行对应的回调函数。但如果该回调函数内部持有对于页面DOM的某个引用或者变量的引用的话，当页面销毁的时候应该注销回调函数。

同样的道理也可以用在页面的事件注册程序上面，页面注册的事件在注销的时候应该进行注销。垃圾回收机制不好判断该事件是否需要被解除，导致 callback 不能被释放，此时需要手动解除绑定：DOM.removeEventListener(callback)

### 6. console.log
控制台日志记录对总体内存内置文件的影响，也是个重大的问题，同时也是容易被忽略的。记录错误的对象，可以将大量的数据保留在内存中。
传递给console.log的对象是不能被垃圾回收，所以没有去掉console.log可能会存在内存泄漏。

