## 什么是垃圾回收机制？
众所周知，在应用程序运行的过程中，无时无刻都在和内存打交道。一般情况下，内存的声明周期为申请-使用-释放，由于计算机的内存空间是有限的，如果在程序的运行过程中所占有的内存空间越来越多，此时就需要我们对未使用或者之前使用了之后不会再使用的内存空间进行回收。

一般来说，垃圾回收机制分为两大类：
1. 手动回收
比如C、C++等语言需要程序员在合适的时刻手动进行垃圾回收，若数据使用完后，没有主动释放的无用内存，就会随着程序运行时间的增加，内存逐渐被占满，这种情况被称为 「内存泄漏」

2. 自动回收
高级语言如Java、JS等程序的执行引擎会周期性的自动进行垃圾回收，对于前端来说，垃圾回收其实是无感知的。

## 自动垃圾回收策略
在JS内存管理中有一个概念叫做可达性，判断一个值是否可达，就看这个值是否可以通过某种形式访问到。如果可以访问，那么是可达的；否则是不可达的，这部分不可达的值就需要在下一次垃圾回收时进行回收。JS垃圾回收机制的原理说白了就是定期找到哪些不再会被用到的内存空间，然后释放其内存。

在GC算法发展的过程中，有两种自动GC算法，是最为常见和使用的，分别是标记清除算法和引用计数算法，下面一一详细说明。

### 一、标记清除算法
#### 1. 策略
到目前为止，大多数的浏览器的JS引擎都在使用这些标记清除算法来实现自动垃圾回收，但是不同的浏览器对这种算法又进行了不同的优化策略，所以不同浏览器的标记清除算法的运行效率是不同的。

标记清除算法顾名思义分为两个步骤：先标记后清除。
1. 标记阶段
JS引擎在执行标记清除算法时，会从根ROOT对象开始，沿着指针遍历访问所有的对象，将可访问到的对象打上一个标记。
然后对于浏览器环境来说，这个根对象不止一个，可能是window对象或者document对象。在标记阶段没有打上标记的就是非活动对象，也就是需要清理的。

2. 清除阶段
在标记阶段没有打上标记的就是非活动对象，也就是需要清理的。在这个阶段会将未标记的对象进行清除。

#### 2. 优点
标记清除算法的优点就是非常简单，并且可以解决对象循环引用而导致无法回收的问题。

#### 3. 缺点
标记清除算法有一个很大的缺点就是在标记清除结束之后，内存空间中已清理和未清理的内存位置不会发生变化，所以会导致清理之后内存空间是不连续的，出现了很多内存碎片。还有一个问题是出现的内存碎片大小不一致，当程序需要分配新的内存空间的时候，还需要一次单向遍历找到适合的内存空间，然后进行使用。

举个例子：假设在回收之后新建一个对象，其需要128个字节大小的内存空间，但由于标记清除算法回收之后导致内存空间的碎片化和不连续，那么我们就需要依次遍历所有大小的内存空间，然后找到一个大于等于128个字节大小的空间之后立即返回。很明显，遍历寻找这个符合大小的内存空间需要时间，当这种操作很多的时候就会影响程序运行速度。

综上所述，标记清除算法有两个缺点：
1. 内存空间碎片化，不连续
2. 分配新的内存空间需要遍历，速度慢，最坏情况是每次都要遍历到最后也就是O(n)的时间复杂度


### 二、标记整理算法
由于标记清除算法会导致内存空间碎片化的缺点，后来又出现了专门解决这个问题的标记整理算法。下面简单说下标记整理算法的过程：
标记整理算法相对于标记清除算法有三个阶段，多了一个整理的阶段：在标记结束之后，标记整理算法会首先将所有不会被清理的对象占有的内存向一端进行移动，然后再清理掉需要被清除的内存空间。这样一来，原本在清理之后会碎片化的内存提前会聚合在一起，解决了标记清除算法内存空间碎片化的问题。

### 三、引用计数算法
#### 1. 策略
引用计数算法是最早出现的一种垃圾回收策略，它把对象是否可以被回收简化为有没有其他对象引用着它，如果没有指向该对象的引用或者指针，那么这个对象的引用个数就是0，这种零引用的对象将会被垃圾回收机制所回收，引用计数算法由于其会导致对象循环引用的问题，目前其实已经很少使用了。
```js
let a = new Object()  // 此对象的引用计数为 1（a引用）
let b = a       // 此对象的引用计数是 2（a,b引用）
a = null        // 此对象的引用计数为 1（b引用）
b = null         // 此对象的引用计数为 0（无引用）
...          // GC 回收此对象
```

#### 2. 优点
引用计数算法的优点是当一个对象的引用计数为0的时候，会被立即进行回收。
而标记清理算法会周期性的每隔一段时间执行一次，会导致程序在运行的时候发生暂停而执行垃圾回收，所以引用计数可以最大限度的减少暂停执行垃圾回收的次数。

#### 3. 缺点
引用计数算法最大的问题就是会导致对象之间的循环引用，比如：
```js
function demo(){
	let a = {};
	let b = {};
	
	// a b对象的循环引用 它们的引用次数都是2
	a.name = b;
	b.age = a;
}
demo()
```
循环引用会导致原本在函数demo执行结束后被清理的对象a和b由于互相引用而无法回收，当这种函数执行越来越多的时候，就会导致大量的内存无法释放的问题。
而如果使用标记清除算法的话，当函数执行结束之后，没有外部的变量保持着对于函数内部对象的引用，所以这两个对象a和b是可以被清除的，这个原因也是导致后来大多数浏览器厂商都抛弃引用计数算法，使用标记清除算法的原因之一。

这里有一个注意点，那就是在IE8 以及更早版本的 IE 中，BOM 和 DOM 对象并非是原生 JavaScript 对象，它是由 C++ 实现的 组件对象模型对象（COM，Component Object Model），而 COM 对象使用 引用计数算法来实现垃圾回收，所以即使浏览器使用的是标记清除算法，只要涉及到 COM 对象的循环引用，就还是无法被回收掉，就比如两个互相引用的 DOM 对象等等，而想要解决循环引用，需要将引用地址置为 null 来切断变量与之前引用值的关系。不过在 IE9 及以后的 BOM 与 DOM 对象都改成了 JavaScript 对象，也就避免了上面的问题

此外引用计数算法还有一个缺点就是它是需要一个计数器来计算每一个对象的引用次数的，这个计数器也会占用很大一部分内存空间，因为我们不知道程序中对象被引用数量的上限。




## JavaScript的垃圾回收机制
我们都知道JavaScript中的值存储于两个不同的内存中，基本类型的值存储于栈内存空间中，引用类型的值存储于堆内存空间中。所以，讨论JavaScript中垃圾回收，我们就要分别搞清楚栈空间的垃圾回收和堆空间的垃圾回收机制两个部分。

### 栈中垃圾回收机制
JavaScript在运行的过程中会创建一系列的执行上下文，当JavaScript执行一个函数的时候，首先会创建一个专门执行此函数的执行上下文，同时有一个ESP指针也就是函数栈顶指针指向当然调用栈中正在执行的函数上下文，当函数执行完成之后，栈内存需要回收，此时JavaScript执行栈内存回收的方法是将ESP指针下移到下一个函数执行上下文上，这个过程就等于将已经执行完成的函数上下文从栈顶弹出，这个过程也就是销毁函数执行上下文并回收该上下文中局部变量的过程。

综上所述，JavaScript对于栈中垃圾的回收其实是基于下移ESP栈顶指针来完成的，这个下移的过程中就会回收被销毁的函数上下文所占有的内存。

### 堆中垃圾回收机制
在了解JavaScript中堆的垃圾回收机制之前，我们首先了解几个关于V8引擎实现GC算法的概念。

#### 1. 代际假说
代际假说的意思是大部分对象在内存中存在的时间是很短暂的，比如很多对象一经分配内存，很快就会变得不可访问，这部分对象占用内存相对较小；
而那些存活时间比较久的对象，相对来说占有内存空间是比较大的，比如window对象、doucment等。

#### 2. 分代式垃圾回收
试想一下，我们上面所说的垃圾清理算法在每次垃圾回收时都要检查内存中所有的对象，这样的话对于一些大、老、存活时间长的对象来说同新、小、存活时间短的对象一个频率的检查很不好，因为前者需要时间长并且不需要频繁进行清理，后者恰好相反，V8引擎为了更好的提高垃圾回收的性能，采用了分代处理。

简单来说就是V8引擎将堆内存空间分为了两大部分：新生代和老生代，并且基于这两种不同代的内存采用不同的垃圾回收器、不同的垃圾回收策略来进行回收，以达到最适合最高性能的垃圾回收策略。

V8 整个堆内存的大小就等于新生代加上老生代的内存：
1. 新生代
存放时间比较短的对象，这部分对象一般比较小，占用内存为1-8M，采用副垃圾回收器进行回收。

2. 老生代
存放生存时间长、比较大的对象，占用内存在64位系统下一般为1.4G左右，采用主垃圾回收器进行回收。

至于为什么V8采用分代式垃圾回收策略，其实本质还是对既有GC算法效率的优化考虑的，将比较小而且新的对象，假设它们存活时间短，这部分对象用新生代区进行高频的清理；对于比较大而且旧的对象，假设它们存活时间长，采用老生区进行比较低频次的清理。

### 新生代区- 副垃圾回收器
#### 1. 新生代区垃圾回收算法
+ 标记清理算法
+ Scavenge复制算法

#### 2. Scavenge算法策略
Scavenge算法是一种复制思想的算法，这种算法会将新生代所占的堆内存再次一分为二：
+ 处于使用状态的我们称之为使用区
+ 处于闲置状态的我们称之为闲置区

首先新加入的对象会放置到使用区域，当使用区域快要满的时候，就需要执行一次垃圾回收操作，具体的流程如下：
1. 对使用区中活动对象进行标记
2. 标记完成之后将使用区的对象全部复制到空闲区域，这个复制过程就等于做了一次整理操作
3. 进入垃圾清理阶段，清理非活动对象内存
4. 角色互换，将空闲区域变为使用区，将使用区变为空闲区

#### 3. Scavenge算法缺点
Scavenge算法由于会不断的进行复制，复制操作本身就是一个耗时的操作，所以会消耗较多的时间。

#### 4. 新生代和老生代的转换
一旦复制一个使用区中对象到空闲区的时候，其占有的内存已经超出了空闲区大小的25%，那么这个对象就会直接从新生代移动到老生代区；
一旦在新生代区中经过两次垃圾回收之后还存在的对象，就会被移动到老生代区


### 老生代区- 主垃圾回收器
#### 1. 老生代区垃圾回收算法
老生代区的垃圾除了从新生代中移动过来的之外，一般都是占用空间大和存活周期长的对象，这部分对象就不能采用Scavenge复制的算法来解决，那样会导致复制的时间过长从而导致垃圾回收阻塞JS主线程的执行。

所以老生代区垃圾回收算法采用了我们之前说过的标记清理和标记整理算法，除了这两个基本算法之外，还使用了增量标记算法来优化GC效率。
+ 标记清理
+ 标记整理
+ 增量标记
只有在内存分配不足的时候会采用标记整理算法对空间进行优化，然后会采用增量标记算法对效率进行优化。


#### 2. 增量标记算法

1. 全停顿（Stop-The-World）
在了解增量标记算法之前，我们先来了解一个概念：全停顿（Stop-The-World）。由于JS在执行的时候是单线程也就是在主线程上执行的，但垃圾回收机制是周期性的会进行垃圾回收，在执行垃圾回收的时候就会阻塞JS的执行，等回收完成之后接着执行，我们把这种阻塞JS主线程执行而进行垃圾回收的行为称之为全停顿。
比如一次 GC 需要 60ms ，那我们的应用逻辑就得暂停 60ms ，假如一次 GC 的时间过长，对用户来说就可能造成页面卡顿等问题。

2. 优化：增量标记算法

增量标记算法其实是V8为了优化这种全停顿导致程序的卡顿而执行的一个优化算法，它的主要思路就是将标记的过程分为一个个小的子标记过程，同时让垃圾标记和JS逻辑运行交替进行，直到标记阶段的完成，让垃圾回收导致全停顿的影响降到最低，我们把这种算法称之为增量标记算法。


## V8对于GC回收时间的优化策略

为了提升用户的体验，减少全停顿的时间，V8引擎还有以下优化策略：

1. 增量标记(上面介绍过)
增量标记在本质上并没有缩短GC执行标记的时间，只是切分成很小的子任务执行，可以提高用户体验

2. 并行回收
并行的意思就是V8运行主线程在执行垃圾回收的同时，新开其他辅助线程来分担主线程的工作，使得垃圾回收所耗费的时间减少。
在新生代区的垃圾回收机制中就使用了并行回收的优化策略：在整理排序阶段，也就是将活动对象从from-to复制到space-to的时候，启用多个辅助线程，并行的进行整理。

3. 并发标记
并发式GC允许在在垃圾回收的同时不需要将主线程挂起，两者可以同时进行，只有在个别时候需要短暂停下来让垃圾回收器做一些特殊的操作。
V8在老生代垃圾回收中，如果堆中的内存大小超过某个阈值之后，会启用并发（Concurrent）标记任务。

4. 惰性清理
增量标记只是针对标记阶段，而惰性清理就是针对清除阶段了。在增量标记之后，要进行清理非活动对象的时候，垃圾回收器发现了其实就算是不清理，剩余的空间也足以让JS代码跑起来，所以就延迟了清理，让JS代码先执行，或者只清理部分垃圾，而不清理全部。这个优化就叫做惰性清理


